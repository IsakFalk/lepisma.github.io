<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>
    What is it that Genetic Algorithm does ? &#8211; abhinav tushar
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="When to use Genetic Algorithm">
  <meta name="author" content="Abhinav Tushar">
  <meta name="keywords" content="articles">
  <link rel="canonical" href="https://lepisma.github.io//articles/2016/06/13/genetic-algorithm/">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/assets/css/pace.css" type="text/css">
  <link rel="stylesheet" href="/assets/css/lightbox.css" type="text/css">
  <link rel="stylesheet" href="/assets/css/animate.min.css" type="text/css">
  <link rel="stylesheet" href="/css/blog.css" type="text/css">

  <!-- Favicon -->
  <link rel="apple-touch-icon-precomposed" sizes="57x57" href="/assets/images/favicons/apple-touch-icon-57x57.png" />
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/assets/images/favicons/apple-touch-icon-114x114.png" />
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/assets/images/favicons/apple-touch-icon-72x72.png" />
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/images/favicons/apple-touch-icon-144x144.png" />
  <link rel="apple-touch-icon-precomposed" sizes="60x60" href="/assets/images/favicons/apple-touch-icon-60x60.png" />
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/assets/images/favicons/apple-touch-icon-120x120.png" />
  <link rel="apple-touch-icon-precomposed" sizes="76x76" href="/assets/images/favicons/apple-touch-icon-76x76.png" />
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/assets/images/favicons/apple-touch-icon-152x152.png" />
  <link rel="icon" type="image/png" href="/assets/images/favicons/favicon-196x196.png" sizes="196x196" />
  <link rel="icon" type="image/png" href="/assets/images/favicons/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/png" href="/assets/images/favicons/favicon-32x32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/assets/images/favicons/favicon-16x16.png" sizes="16x16" />
  <link rel="icon" type="image/png" href="/assets/images/favicons/favicon-128.png" sizes="128x128" />
  <meta name="application-name" content="&nbsp;"/>
  <meta name="msapplication-TileColor" content="#FFFFFF" />
  <meta name="msapplication-TileImage" content="/assets/images/favicons/mstile-144x144.png" />
  <meta name="msapplication-square70x70logo" content="/assets/images/favicons/mstile-70x70.png" />
  <meta name="msapplication-square150x150logo" content="/assets/images/favicons/mstile-150x150.png" />
  <meta name="msapplication-wide310x150logo" content="/assets/images/favicons/mstile-310x150.png" />
  <meta name="msapplication-square310x310logo" content="/assets/images/favicons/mstile-310x310.png" />

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,300,800" rel="stylesheet" type="text/css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono" rel="stylesheet">

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
  <script src="/assets/js/pace.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script src="/assets/js/lightbox.min.js"></script>
  <script src="/assets/js/jquery.lettering-0.6.1.min.js"></script>
  <script src="/assets/js/jquery.textillate.js"></script>
  <script src="/assets/js/custom.js"></script>

  <meta property="og:locale" content="en_US">
  <meta property="og:type" content="article">
  <meta property="og:title" content="What is it that Genetic Algorithm does ?">
  <meta property="og:description" content="Personal Blog">
  <meta property="og:url" content="https://lepisma.github.io//articles/2016/06/13/genetic-algorithm/">
  <meta property="og:site_name" content="abhinav tushar">

  <meta name="twitter:url" content="https://lepisma.github.io//articles/2016/06/13/genetic-algorithm/">
  <meta name="twitter:title" content="What is it that Genetic Algorithm does ?">
  <meta name="twitter:description" content="Personal Blog">

  <meta itemprop="name" content="What is it that Genetic Algorithm does ?">
  <meta itemprop="description" content="Personal Blog">
</head>

  <body>
    <div class="site-wrap">
      <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <span class="site-title">
        <a href="/">
          <img src="/assets/images/avatar32.png">
        </a>
      </span>
      <nav class="site-nav right">
        <a href="/">home</a>
<a href="/feed.xml">feed</a>
<a href="/archive">archive</a>
<a href="/about/">about</a>

      </nav>
      <div class="clearfix"></div>
    </div>
  </div>
</header>


      <div class="post p2 p-responsive wrap" role="main">
        <div class="measure">
          


<div class="post-header mb2">
  <h1>What is it that Genetic Algorithm does ?</h1>
  <span class="post-meta small">Jun 13, 2016</span><br>
  <span class="post-meta small">9 minute read</span>
</div>

<article class="post-content">
  <p><span class="dropcap">B</span>eing interested in heuristic optimization methods,
one thing I notice a lot is <em>confusion</em> in the applicability and efficiency of
the methods. Mind you, I am not expert enough to resolve the doubts, but have an
opinion which might help in <em>‘some’</em> situations. Ask around for methods to do
derivative free optimization and you will stop keeping the count after a while.
Specifically in the category of metaheuristics; <em>Cuckoo Search</em>, <em>Genetic
Algorithm</em>, <em>Stimulated Annealing</em>, <em>Tabu Search</em> etc. etc. But there is an issue.
Give the algorithms a first glance and you will feel they are different. Give
them a second glance and many of them will start to cluster in groups. Give a
third glance and they are different again!</p>

<p>Earlier, due to the reducible design, I used to consider Genetic Algorithm (GA) as a
more general technique as compared to many other evolutionary methods. But then,
this might not be what we mean when we want a generally <em>applicable</em> method.
A simplistic representation embodying the general principle, like
“<strong>mutation</strong> in population” for population based heuristics, is what I was
looking for instead. GA is, in essence, much more powerful if used in
specialized setting with knowledge of the problem. I will go over this
proposition later.</p>

<p>Genetic Algorithm faces a lot of criticism. Criticism from researchers are
<em>usually</em> constructive. For example there has been a lot of ‘debate <strong>and</strong> work’
on the role of crossover in GAs. But I have also seen the users and learners
frowning at few of its aspects without going through what it is that GA really
does.</p>

<h2 id="fundamental-ideas">Fundamental ideas</h2>

<p>The main source of inspiration for GA is sexual reproduction. The core ideas
including mate selection, gene crossover and mutation are all faithfully (to a
certain level of abstraction) incorporated in it. But there are vital differences
between the role of sexual reproduction and our needs from GA, a topic covering
the meaning of <em>fitness functions</em> and its population aggregate. Let us leave
the way fitness is used in traditional GA and focus on the two <em>major</em>
operations.</p>

<h3 id="mutation">Mutation</h3>

<p>This is simply what every other random search algorithm does. Slight change from
the current solution. Using a bit string solution representation like
\(0100100\), a simple point mutation along with fitness based selection
procedure essentially is the hill climb algorithm. Change bits, evaluate the new
positions and shift the population towards the better fitness. This case is
stronger with situations including \(N\to\infty\) (larger population size,
\(N\)), higher rate of mutation, elite individuals etc.</p>

<p>Mutation coupled with a population and selection procedure results in a nice
global optimizer. Even more important is the ease of understanding the word
<em>“mutation”</em> with respect to the problem representation. Use bit strings or
direct real values or other symbols, mutation means what it means.</p>

<h3 id="crossover">Crossover</h3>

<p>In a common representation, a crossover operation swaps sections of solution
strings from two mating parents. Now, this needs a little bit of digging. What
purpose copying a snippet of gene from parents to children could have? <em>To inherit
 and move around some specific <strong>chunks</strong> of functional properties</em>.</p>

<p>A topic of debate among researchers is whether crossover actually has some
theoretical advantage and meaning for the problems. Some arguments reduce
crossover as a fancy form of mutation, while some arguments support its usage
separately.</p>

<p>Without going into the arguments, its better to stick to the
fundamentals of crossover and, as a user, exploit its basics. <em>It maintains
chunks of properties among the population and across generations.</em></p>

<p>In GA, you can represent the solution as <em>chromosomes</em> in multiple ways. A
common method to represent real number parameters is to use direct value
encoding. Let the fitness function simply be \(f(a)\). For crossing over
individuals in this form, there are blending and interpolation techniques for
numbers. While mating two solutions, \(a_{1}\) and \(a_{2}\), a simple
\(\alpha\) blending gives</p>

<script type="math/tex; mode=display">a_{3} = \alpha a_{1} + (1-\alpha) a_{2}</script>

<p>Now, here is what the wikipedia
<a href="https://en.wikipedia.org/wiki/Differential_evolution">page</a> on Differential
Evolution (DE) says</p>

<blockquote>
  <p>DE optimizes a problem by maintaining a population of candidate solutions and
creating new candidate solutions by combining existing ones according to its
simple formulae, and then keeping whichever candidate solution has the best
score or fitness on the optimization problem at hand.</p>
</blockquote>

<p>Is there an identity crisis here?</p>

<h2 id="fundamental-ideas-again">Fundamental ideas, again</h2>

<p>Look, everything works. Some variations are better and there are theoretical and
empirical results backing them up. But then sometimes I feel it is unfair to
throw any problem at GA assuming it as a general purpose optimizer. Back to the
proposition made in the beginning of the post and the main question of the post.
I really like to think the answer to be something on the following lines</p>

<blockquote>
  <p>GA provides a framework for manipulation of a structure made from <strong>symbols</strong>
to achieve a desired behaviour in decently low time.</p>
</blockquote>

<p>Many variations of GA stick to this idea.
<a href="https://en.wikipedia.org/wiki/Genetic_programming">Genetic Programming</a> is a
nice example. Consider following lisp sexpr:</p>

<div class="language-elisp highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">defun</span> <span class="nv">test-function</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">x</span><span class="p">)</span>
    <span class="s">"Evaluate negative of slope of function at x"</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">dx</span> <span class="mf">0.01</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">*</span> <span class="mi">-1</span>
            <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">-</span>
                <span class="p">(</span><span class="nv">fn</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">dx</span><span class="p">))</span>
                <span class="p">(</span><span class="nv">fn</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="nv">dx</span><span class="p">)))</span>
                <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="nv">dx</span><span class="p">)))))</span>
</code></pre>
</div>

<p>The function is approximating the (-ve of) slope of another function by calculating</p>

<script type="math/tex; mode=display">- \frac{fn(x + \Delta x) - fn(x - \Delta x)}{2 \times \Delta x}</script>

<p>The tree structure of operations has usable chunks which are essential to get
the final output. Consider the numerator chunk.</p>

<div class="language-elisp highlighter-rouge"><pre class="highlight"><code><span class="c1">;; ...</span>
<span class="p">(</span><span class="nb">-</span>
    <span class="p">(</span><span class="nv">fn</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">dx</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">fn</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="nv">dx</span><span class="p">)))</span>
<span class="c1">;; ...</span>
</code></pre>
</div>

<p>This generates an important template for good solutions if you want a quantity
like slope. In GA terminology, this template consisting of some form of fixed
structure and spaces for variations is called <strong>schema</strong>. This schema has a
fitness associated with it which is the average of fitness of all solutions
matching this template. For the above template, the fitness is good since most
of the variations around the template will result in some simple operation on
the difference of function values. This is better than a case, say, where the
template is a sum of function values at two neighbouring points.</p>

<p>The
<a href="https://en.wikipedia.org/wiki/Holland%27s_schema_theorem">fundamental theorem of GA</a>
says that the <em>power</em> of GA comes from increasing the population fraction of
schemata with smaller fixed parts and better fitness over generations. The
better schemata survive the operations and live on.</p>

<hr />

<p>Now here is a case. I was using the traditional value encoded form of GA for a
global optimization at some point in my undergraduate life. I kept the approach
somewhat similar to Matlab’s. Value encoding, elite individuals, gaussian mutation,
simulated binary crossover and tournament selection. It did whatever it was
meant to. But then I started to fiddle around a bit with parameters and switches
(whether to use this operation, that selection criteria etc.) and realized that
I am doing what can be called
<em><a href="https://en.wikipedia.org/wiki/Cargo_cult_science">cargo cult</a> tuning</em>.</p>

<p>Consider the following fitness surface and value encoding. Considering crossover
as extrapolations along some dimension, you can see two kind of results of
mating. One better, one worse. That’s fine, it happens in real crossovers too.</p>

<figure>
<img src="/images/posts/ga/surf.png" />
</figure>

<p>But the point is, user can’t seem to understand and extract the <em>power</em> of
GA here. What are the schemata getting passed on? Where the crossover points
are? More importantly, what can I do to improve performance?</p>

<p>In my opinion, its better to use a method whose <em>knobs</em> (parameters etc.)
correspond to the problem in hand and which <em>really</em> pass on the essence of the
<em>operations</em> as some connectable effects on the problem. And then judge the
algorithm, in case a judgment is to be made.</p>

<p>Last year, Randy Olson
<a href="http://www.randalolson.com/2015/02/03/heres-waldo-computing-the-optimal-search-strategy-for-finding-waldo/">blogged</a>
about solving a Travelling Salesman Problem (TSP) with Genetic Algorithm. TSP
solutions have chunks of continuous paths which can be locally optimal.
Debugging makes sense here because the operations are intuitive. Also consider
<a href="https://en.wikipedia.org/wiki/Neuroevolution_of_augmenting_topologies">NEAT</a>,
which <em>evolves</em> neural network structures. Same idea. Manipulation of symbols
and <em>actual</em> implications of crossovers (of chunk of structural trees lets say)
etc. Similar is the case with many examples which use Genetic Programming. There
are cases where a genetic approach actually provides easier implementation and
better results than other methods.</p>

<p>I found this piece of criticism by
<a href="https://en.wikipedia.org/wiki/Steven_Skiena">Steven Skiena</a> on Wikipedia page
of GA</p>

<blockquote>
  <p>[I]t is quite unnatural to model applications in terms of genetic operators
like mutation and crossover on bit strings. The pseudobiology adds another
level of complexity between you and your problem.</p>
</blockquote>

<p>The problem Skiena is addressing is important. The operators are not intuitive
at all for general problems and add on the burden of the user. Well, you do get
good performance than other methods in different cases. But my opinion is to
<em>respect</em> [the full fledged] GA for its help <em>“in context”</em> of a certain class of
problem, not as a go-to general purpose optimizer (for which you would be better
started by programming a simple and quick disruptive method).</p>

<p>Your problem can have some allowed set of schemata. For example, if you have a
bit string representation of 3-4 parameters, you might like a form of schemata
which break the string at the junctions of the numbers for crossovers. Or in
some cases you might want to group few bits of strings and evolve them
separately. You can try inspirations from <em>speciation</em>. You can create <em>artificial
islands</em>. You can try some weird animal group behaviour. They all are good <strong>if</strong>
your problem needs them and the effects are reflected in the evolution of
solutions. Otherwise, they are another set of instances of misjudgment of the
method.</p>

</article>

        </div>
      </div>
    </div>

    <footer class="footer">
</footer>

  </body>
</html>
